0 info it worked if it ends with ok
1 verbose cli [ 'C:\\Program Files\\nodejs\\node.exe',
1 verbose cli   'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
1 verbose cli   'publish' ]
2 info using npm@3.10.10
3 info using node@v6.10.3
4 verbose publish [ '.' ]
5 silly cache add args [ '.', null ]
6 verbose cache add spec .
7 silly cache add parsed spec Result {
7 silly cache add   raw: '.',
7 silly cache add   scope: null,
7 silly cache add   escapedName: null,
7 silly cache add   name: null,
7 silly cache add   rawSpec: '.',
7 silly cache add   spec: 'D:\\_Dev\\NodeJS\\github\\mixin-interface-api',
7 silly cache add   type: 'directory' }
8 verbose addLocalDirectory C:\Users\maruti\AppData\Roaming\npm-cache\mixin-interface-api\0.1.17\package.tgz not in flight; packing
9 verbose correctMkdir C:\Users\maruti\AppData\Roaming\npm-cache correctMkdir not in flight; initializing
10 info lifecycle mixin-interface-api@0.1.17~prepublish: mixin-interface-api@0.1.17
11 silly lifecycle mixin-interface-api@0.1.17~prepublish: no script for prepublish, continuing
12 verbose tar pack [ 'C:\\Users\\maruti\\AppData\\Roaming\\npm-cache\\mixin-interface-api\\0.1.17\\package.tgz',
12 verbose tar pack   'D:\\_Dev\\NodeJS\\github\\mixin-interface-api' ]
13 verbose tarball C:\Users\maruti\AppData\Roaming\npm-cache\mixin-interface-api\0.1.17\package.tgz
14 verbose folder D:\_Dev\NodeJS\github\mixin-interface-api
15 verbose addLocalTarball adding from inside cache C:\Users\maruti\AppData\Roaming\npm-cache\mixin-interface-api\0.1.17\package.tgz
16 verbose correctMkdir C:\Users\maruti\AppData\Roaming\npm-cache correctMkdir not in flight; initializing
17 silly cache afterAdd mixin-interface-api@0.1.17
18 verbose afterAdd C:\Users\maruti\AppData\Roaming\npm-cache\mixin-interface-api\0.1.17\package\package.json not in flight; writing
19 verbose correctMkdir C:\Users\maruti\AppData\Roaming\npm-cache correctMkdir not in flight; initializing
20 verbose afterAdd C:\Users\maruti\AppData\Roaming\npm-cache\mixin-interface-api\0.1.17\package\package.json written
21 silly publish { name: 'mixin-interface-api',
21 silly publish   version: '0.1.17',
21 silly publish   description: 'Lightweight interface class API (Javascript es6)',
21 silly publish   main: 'main.js',
21 silly publish   scripts: { test: 'node test.js' },
21 silly publish   repository:
21 silly publish    { type: 'git',
21 silly publish      url: 'git+https://github.com/Echopraxium/mixin-interface-api.git' },
21 silly publish   keywords:
21 silly publish    [ 'mixin',
21 silly publish      'interface class',
21 silly publish      'implementation class',
21 silly publish      'implements',
21 silly publish      'service',
21 silly publish      'javascript es6' ],
21 silly publish   author: { name: 'Michel Kern' },
21 silly publish   license: 'MIT',
21 silly publish   bugs: { url: 'https://github.com/Echopraxium/mixin-interface-api/issues' },
21 silly publish   homepage: 'https://github.com/Echopraxium/mixin-interface-api#readme',
21 silly publish   dependencies:
21 silly publish    { 'caller-id': '^0.1.0',
21 silly publish      mixin: '^0.2.0',
21 silly publish      'sprintf-js': '^1.1.1' },
21 silly publish   readme: '# mixin-interface-api\r\n\r\nA lightweight _interface class_ API in Javascript es6 (ECMAScript 2015). It is implementated with `mixins`, Type checking and inheritance are supported.\r\n\r\n### Changelog in release 0.1.18\r\nThis release brings a much better and modern implementation of the _Log feature_ with the _sink metaphor_. \r\n >This idea is neither new nor mine but I thought that it would be very nice to have. You\'re welcome to read [this article](http://tutorials.jenkov.com/api-design/avoid-logging.html) and take a look at the [Serilog library](https://serilog.net/).\r\n\r\nNow the _Log client_ sends a _trace request_ (`MxI.$Log.write()`), then the _trace message_ is eventually processed by being sent to a specific _target_ (e.g. _Console_, _File_, _Server_, _Database_, etc...). \r\nThe _sink(s)_ must be explicitly declared (`MxI.$Log.addSink()`) else the _trace request_ is not processed.  \r\n >Notice that _sink_ classes must implement `MxI.$ILogSink` but they are no more singletons.\r\n\r\n* Major refactoring of Log API: step 1/2 - move some classes from `mixin-interface` to `mixin-interface-api`  \r\n  * `MxI.$ILogger` interface moved and renamed to `MxI.$ILogSink`.\r\n  * `MxI.$DefaultLogger` implementation moved and renamed to `MxI.$ConsoleLogSink`.\r\n  * Implementation of _Log feature_ moved from `MxI.$System` class to `MxI.$Log` class. Please notice that the previous API (e.g. `MxI.$System.log()`) is still supported but is now _deprecated_.  \r\n\r\n  \r\n* Major refactoring of Log API: step 2/2 - New implementation classes in `mixin-interface-api`  \r\n  * `MxI.$Log` is the new implementation of the _Log feature_ in which _trace requests_ are processed by _sink(s)_. A _sink_ redirects traces (`MxI.$Log.write()` calls) to specific target (e.g. `$ConsoleLogSink` redirects to the console). \r\n  * `MxI.$FileLogSink` is a _sink_ which redirects traces (`MxI.$Log.write()` calls) to a file (e.g. `log.txt`).  \r\n\r\n### Changelog in release 0.1.6 \r\n* Documentation upgrade 1/2: UML model diagram for the implementation sample\r\n* Documentation upgrade 2/2: Paragraphs reordering ( _Sample UML Model_, "howtos" i.e _How to Define an Interface class_ and _Core API Reference_ are now before _Installation and Usage_ and _How to run the Unit Test_)\r\n\r\n## Sample UML Model\r\n![alt text](img/sample_1.png "Sample UML Model")\r\n\r\nPlease find below the explanations with wich you may implement this model with the Core API privided by `mixin-interface-api`\r\n\r\n## How to Define an Interface class\r\nHere is an example of an _interface class_ (see [`./src/test_classes/i_life_form.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/i_life_form.js). Here we define a single service: `live()`\r\n\r\n* Inherit from `MxI.$IBaseInterface` (or any other _super_interface_ if applicable) by using `MxI.$Interface()` just after the es6 `extends` keyword to define both that it is an _interface class_ and that its _super_interface_ is `MxI.$IBaseInterface`. \r\n* Use `MxI.$raiseNotImplementedError()` in order to guarantee that the service is provided by the _implementation_. This should be put in the _Fallback implementation_ of each service defined by the interface. \r\n\r\n >This will raise an Error if an _implementation_ which declares it implements this _interface_ misses one or more service implemention(s) (see paragraph on `MxI.$raiseNotImplementedError` API service at the end of this document).  \r\n* Add the `MxI.$setAsInterface().$asChildOf()` _idiom_ after the class definition to define that this is an _interface_class_ and what is its superclass.\r\n\r\n>Note: To remind that a class is an _interface class_, it is strongly advised to use the \'_I prefix_\' naming convention as  a reminder. This is a reminiscence of [_Hungarian notation_](https://en.wikipedia.org/wiki/Hungarian_notation) , a fairly old _identifier naming convention_ (e.g. see [Microsoft COM](https://fr.wikipedia.org/wiki/Component_Object_Model))\r\n\r\n```javascript\r\nconst MxI = require(\'../mixin_interface_api.js\').MxI;\r\n//==================== \'ILifeForm\' interface class ====================\r\nclass ILifeForm extends MxI.$Interface(MxI.$IBaseInterface) {  \r\n  // Fallback implementation of \'live\' service\r\n  live() {\r\n    MxI.$raiseNotImplementedError(ILifeForm, this);\r\n  } // ILifeForm.live()\r\n} // \'ILifeForm\' class\r\nMxI.$setAsInterface(ILifeForm).$asChildOf(MxI.$IBaseInterface);\r\nexports.ILifeForm = ILifeForm;\r\n```\r\n>Note: Each _interface class_ must have a superclass (`MxI.$IBaseInterface` if no other _interface class_ applies). In the previous case `MxI.$setAsInterface()` may be used without appending `.$asChildOf(super_interface)` idiom because `MxI.$IBaseInterface` will be the default superclass. However it is both cleaner, safer, more consistent and strongly advised to always use the full _idiom_ (`MxI.$setAsInterface().$asChildOf()`)\r\n\r\n## How to subclass an Interface class\r\nHere is an example of a subclass of an _interface class_ (see [`./src/test_classes/i_animal.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/i_animal.js)). Here we want to define `IAnimal` as a subclass of the `ILifeForm` _interface class_.\r\n\r\n* Use this syntax: `class IAnimal extends $Interface()` to define that `IAnimal` is a subclass of `ILifeForm`.\r\n* Add the `MxI.$setAsInterface().$asChildOf()` _idiom_ just after the class definition.\r\n\r\n >This is required so that `MxI.$isInstanceOf()` works properly to identify an object both as an being an instance of an _implementation class_ (and its superclasses) as well being an instance of an _interface class_ (and its superclasses).\r\n\r\n* We then define a new service: `run()`. It will be a regular method of a javascript es6 class. \r\n* Use `MxI.$raiseNotImplementedError()` in order to guarantee that the service is provided by the _implementation class_. This should be put in the _Fallback implementation_ of each service defined by the interface. \r\n\r\n >This will raise an error if the _implementation class_ does\'nt provide (directly or via inheritance) one of the service(s) defined by the _interface class(es)_ (see paragraph on `MxI.$raiseNotImplementedError` API service at the end of this document). \r\n\r\n```javascript\r\nconst MxI       = require(\'../mixin_interface_api.js\').MxI;\r\nconst ILifeForm = require(\'./i_life_form.js\').ILifeForm;\r\n//==================== \'IAnimal\' interface class ====================\r\nclass IAnimal extends MxI.$Interface(ILifeForm)  {\r\n  // Fallback implementation of \'run\' service\r\n  run() {\r\n    MxI.$raiseNotImplementedError(IAnimal, this);\r\n  } // IAnimal.run\r\n} // \'IAnimal\' class\r\nMxI.$setAsInterface(IAnimal).$asChildOf(ILifeForm);\r\nexports.IAnimal = IAnimal;\r\n```\r\n\r\n## How to code an Implementation class\r\nHere is an example of an _implementation class_ (see [`./src/test_classes/animal.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/animal.js)). An _implementation_ may implement one or more _interface classes_. To implement the services (i.e. defined by the _interface class(es)_ that are declared as implemented by this class) we must:\r\n\r\n* Inherit from `MxI.$Object` (or any of its subclasses) by using the `MxI.$Implementation().$with()` _idiom_ just after the es6 `extends` keyword to define both a subclass and the _interface class(es)_ that it implements (`IAnimal` here). \r\n \r\n >Inheriting from `MxI.$Object` also provides the _automatic instance naming_ feature (this feature is provided by the `name` attribute on each instance of `MxI.$Object` or any of its subclasses. Each instance name is generated from its class name and its instance count. \r\n > Instances are named with _SerpentCase_ pattern (e.g. `flying_fish_0`)\r\n \r\n* Put `MxI.$setClass(Animal).$asImplementationOf(ILifeForm, IAnimal)` _idiom_ just after the class definition. \r\n\r\n >This is syntactically redundant but nevertheless required in order that `MxI.$isInstanceOf()` works correctly (see paragraph on `MxI.$isInstanceOf` API service at the end of this document). \r\n\r\n* Provide implementation of all services (e.g. `live()`, `run()`, ...) defined in each interface as well as their parent interfaces. \r\n\r\n >If a service is not provided it may be inherited from the parent _implementation class_.\r\n\r\n```javascript\r\nconst MxI        = require(\'../mixin_interface_api.js\').MxI;\r\nconst IAnimal    = require(\'./i_animal.js\').IAnimal;\r\nconst ILifeForm  = require(\'./i_life_form.js\').ILifeForm;\r\n//==================== \'Animal\' implementation class ====================\r\nclass Animal extends MxI.$Implementation(MxI.$Object).$with(IAnimal) {\r\n  constructor() {\r\n    super();\r\n  } // \'Animal\' constructor\r\n\r\n  run() {\r\n    MxI.$Log.write("--> Animal.run: \'%d\'", this);\r\n  } // IAnimal.run()\r\n\r\n  live() {\r\n    MxI.$Log.write("--> Animal.live: \'%d\'", this);\r\n  } // ILifeForm.live()\r\n} // \'Animal\' class\r\nMxI.$setClass(Animal).$asImplementationOf(IAnimal, ILifeForm);\r\n```\r\n\r\n## How to subclass an Implementation class\r\nHere is an example of how to subclass an _implementation class_ (see [`./src/test_classes/cat.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/cat.js)). Here we want to both to subclass `Animal` and implement the `IMammal` _interface class_, this is how to do it:\r\n\r\n* Inherit from `Animal` by using the `MxI.Implementation().$with()` _idiom_ just after `extends` to define both a subclass and the _interfaces_ that it implements.\r\n* Provide implementation of the service defined by `IMammal` (`suckle()`). If a service from the parent _interfaces_ is not provided then it may be inherited from the parent _implementation class_.\r\n\r\n >Notice this is the case in the following sample: for `run()` an `live()`, as they are _disabled_ by the `__` prefix then it is the implementation from the parent class which is inherited instead.\r\n\r\n* Add the `MxI.$setClass(Cat).$asImplementationOf(IMammal)` _idiom_ just after the class definition. \r\n\r\n >This is required so that `MxI.$isInstanceOf()` works properly to identify an object both as being an instance of an _implementatio class_ (and its superclass(es)) as well being an instance of an _interface class_ (and its superclass(es)).\r\n\r\n```javascript\r\nconst MxI     = require(\'../mixin_interface_api.js\').MxI;\r\nconst Animal  = require(\'./animal.js\').Animal;\r\nconst IMammal = require(\'./i_mammal.js\').IMammal;\r\n//==================== \'Cat\' implementation class ====================\r\nclass Cat extends MxI.$Implementation(Animal).$with(IMammal) {\r\n  constructor() {\r\n    super();\r\n  } // \'Cat\' constructor\r\n\r\n  suckle() {\r\n    MxI.$Log.write("--> Cat.suckle: \'%d\'", this);\r\n  } // IMammal.suckle()\r\n\r\n  __run() {\r\n    MxI.$Log.write("--> Cat.run: \'%d\'", this);\r\n  } // IAnimal.run()\r\n\r\n  __live() {\r\n    MxI.$Log.write("--> Cat.live: \'%d\'", this);\r\n  } // ILifeForm.live()\r\n} // \'Cat\' class\r\nMxI.$setClass(Cat).$asImplementationOf(IMammal);\r\n```\r\n>Notice that `IAnimal.run()` and `ILifeForm.live()` services are not provided, so they are inherited from the parent _implementation class_ (`Animal`).\r\n\r\n- - - -\r\n# Core API Reference\r\n\r\nPlease note the following keywords and their meaning: \r\n  \r\n> **API service**: _function provided by \'mixin-interface\'_ (e.g. `Mxi.$isInstanceOf()`)  \r\n> **MxI**: _namespace_ for all the _mixin-interface_ API services  \r\n> **object**: _instance of an _implementation class_   \r\n> **service**: _function defined by an interface class_ (e.g. `IAnimal.run()`)   \r\n> **type**: either an _implementation class_ (e.g. `Animal`) or an _interface class_ (e.g. `IAnimal`)    \r\n> **interface**: _interface class_  \r\n> **super_interface**: _superclass of the interface class_  \r\n> **implementation**: _implementation class_  \r\n> **super_implementation**: _superclass of the implementation class_   \r\n> **...interfaces**: _list of implemented interfaces_. The list is provided as _interface class(es)_ separated by a comma (e.g. `ILifeForm` and `IAnimal, ILifeForm` are valid _...interfaces_ arguments)  \r\n\r\n* **MxI.$isInstanceOf()**: replacement for javascript `instanceof` operator  \r\n* **MxI.$isInterface()**: checks if a _type_ is an _interface class_ or not  \r\n* **MxI.$implements()**: checks if a _type_ implements an _interface class_ or not  \r\n* **MxI.$getSuperclass()**: get the superclass of a a _type    \r\n\r\n* **MxI.$Interface()**: defines an _interface class_ and its _super_interface_   \r\n* **MxI.$setAsInterface().$asChildOf()**: defines that a class is an _interface class_ and its _super_implementation_  \r\n >This is syntactically redundant but nevertheless required in order that `MxI.$isInstanceOf()` works correctly    \r\n\r\n* **MxI.$Implementation().$with()**: defines an _implementation class_ and its superclass (`Mxi.$Object` if no other class applies)    \r\n* **MxI.$setClass().$asImplementationOf()**: defines  the _interface class(es)_ implemented by an _implementation class_  \r\n\r\n* **MxI.$raiseNotImplementedError()**: error handling when a service (defined by of an _interface class_) is not implemented  \r\n\r\n* **MxI.$Object.init()**: _Delayed Initialization_ feature  \r\n* **MxI.$Object.isInitialized()**: checks if an object has been initialized  \r\n\r\n* **MxI.$ISingleton**: _interface class_ for the _Singleton_ (i.e. Unique instance) design pattern (see [`design-patterns-api`](https://www.npmjs.com/package/design-patterns-api))\r\n* **MxI.$Singleton**: Default _implementation_ for `MxI.$ISingleton` _interface_  \r\n* **MxI.$isSingleton()**: Checks if an object is a _Singleton_  \r\n* **MxI.$setAsSingleton()**: Required to define that an _implementation_ is a _Singleton_  \r\n\r\n* **MxI.$INullObject**: _interface class_ for the _Null Object_ design pattern (see [`design-patterns-api`](https://www.npmjs.com/package/design-patterns-api))\r\n* **MxI.$NullObject**: Default _implementation_ for `MxI.$INullObject` _interface_  \r\n* **MxI.$Null**: Singleton of `MxI.$NullObject` \r\n* **MxI.$isNull()**: Returns `true` in 2 cases. The first is when the input value is an object which is both a _Null Object_ an a _Singleton_ (typically the \'default Null Object\' which is `MxI.$Null`). The second case is when the input value is `undefined`\r\n \r\n* **Log Feature**\r\n >This feature was previously implemented by `MxI.$System` (in `mixin-interface` package). `MxI.$System` still supports the previous implementation but is now _deprecated_.\r\n  * **MxI.$ILogSink**: interface class for a _sink_ (implementation of the Log feature).\r\n  * **MxI.$Log.write(arg_msg, ...arg_values)**: new implementation of _trace requests_.  \r\n  * **MxI.$Log.banner()**: outputs `arg_msg` within a banner.\r\n  * **MxI.$Log.addSink()**: declares a _sink_ object (which must implement `$ILogSink`).\r\n  * **MxI.$Log.getSinkCount()**: returns the number of _sinks_.   \r\n  * **MxI.$Log.clearSinks()**: deletes all the _sinks_.\r\n  * **MxI.$ConsoleLogSink**: default _sink_ implementation class (sends _trace messages_ to the console).\r\n  * **MxI.$FileLogSink**: default _sink_ implementation class (sends _trace messages_ to a file - e.g. `./log.txt`).\r\n***\r\n## Check if an object is an instance of a Type\r\n```javascript\r\nMxI.$isInstanceOf(type, object)\r\n```\r\nThis service provides type-checking for an object (see `./test.js` for a unit test of this feature). The `type` argument is either an _implementation class_ or an _interface class_. This API service allows to identify an object as being both an instance of an _interface class_ (and its superclass(es)), as well as an instance of an _implementation class_ (and its superclass(es)\r\n > This service is a replacement for javascript `instanceof` operator\r\n\r\n```javascript\r\nvar a_cat = new Cat();\r\nMxI.$Log.write(a_cat.name + " is a \'IMammal\': " + MxI.$isInstanceOf(IMammal, a_cat));\r\n```\r\n\r\n***\r\n## Check if a type is an Interface class\r\n```javascript\r\nMxI.$isInterface(type)\r\n```\r\nThis service checks if  `type` is an _interface class_ (see [`./test.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/test.js) for a unit test of this feature). The `type` argument is either an _implementation class_ or an _interface class_.\r\n\r\n```javascript\r\nMxI.$Log.write("\'IAnimal\' is an interface ? " + MxI.$isInterface(IAnimal));\r\n```\r\n\r\n***\r\n## Check if an _implementation_ implements an _interface class_  \r\n```javascript\r\nMxI.$implements(implementation, interface)\r\n```\r\n\r\n***\r\n## Get the superclass of a _type_  \r\n```javascript\r\nMxI.$getSuperclass(type)\r\n```\r\n\r\n***\r\n## Definition of an Interface class\r\n```javascript\r\nMxI.$Interface(super_interface)\r\nMxI.$setAsInterface(interface).$asChildOf(super_interface) \r\n```\r\nThese services allow to define an _interface class_:\r\n\r\n* Use `MxI.$Interface()` after the `extends` clause of the es6 javascript `class` definition \r\n* After the class definition, use the `MxI.$setAsInterface().$asChildOf()` _idiom_\r\n\r\nExample (see [`./src/test_classes/i_animal.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/i_animal.js) for a full sample):\r\n```javascript\r\nclass IAnimal extends MxI.$Interface(ILifeForm)  {\r\n  ...\r\n} // \'IAnimal\' class\r\nMxI.$setAsInterface(IAnimal).$asChildOf(ILifeForm);\r\n```\r\nThis code means that `IAnimal` is an _interface class_ which is a subclass of `ILifeForm`\r\n\r\n***\r\n## Implementation of Interface class(es)\r\n```javascript\r\nMxI.$Implementation(super_implementation).$with(...interfaces)\r\nMxI.$setClass(implementation).$asImplementationOf(...interfaces)\r\n```\r\nThese services allow to define an _implementation class_:\r\n\r\n* Use `MxI.$Implementation()` after the `extends` clause of the es6 javascript `class` definition\r\n* After the class definition, use the `MxI.$setClass().$asImplementationOf()` _idiom_\r\n\r\nExample (see [`./src/test_classes/animal.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/animal.js) for a full sample):\r\n```javascript\r\nclass Animal extends MxI.$Implementation(MxI.$Object).$with(IAnimal) {\r\n  ...\r\n} // \'Animal\' class\r\nMxI.$setClass(Animal).$asImplementationOf(IAnimal, ILifeForm);\r\n```\r\nThis code means:\r\n\r\n* `Animal` is an _implementation class_ which is a subclass of `MxI.$Object` \r\n* `Animal` implements both `IAnimal` and `ILifeForm` _interface classes_\r\n\r\n***\r\n## Error Handling: \'service not implemented\'\r\n```javascript\r\nMxI.$raiseNotImplementedError(_interface_, this)\r\n```\r\nThis service provides _Error Handling_ when a service of an _interface class_ is not provided by an _implementation class_. It should be used in the _Fallback implementation_ for each service defined by the _interface class_.\r\nHere is an example of how to use this API service (see [`./src/test_classes/i_life_form.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/i_life_form.js):\r\n```javascript\r\nclass ILifeForm extends MxI.$Interface(MxI.$IBaseInterface) {  \r\n  // Fallback implementation of \'live\' service\r\n  live() {\r\n    MxI.$raiseNotImplementedError(ILifeForm, this);\r\n  } // ILifeForm.live()\r\n} // \'ILifeForm\' class\r\nMxI.$setAsInterface(ILifeForm).$asChildOf(MxI.$IBaseInterface);\r\n```\r\n\r\nLet\'s see what happens if the `Animal` _implementation_ doesn\'t provide an implementation for the `run()` service §defined by `IAnimal` _interface class_). \r\nIf you want to test this use case, just rename `run()` to `__run()` in [`./src/test_classes/animal.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/test_classes/animal.js) ), then restart the Unit Test with `node test.js` in the command shell. An exception should be raised an you would get the following output:\r\n```bash\r\n    throw new Error(error_msg);\r\n    ^\r\n\r\nError: ** mixin-interface-api **\r\n   Error code:  SERVICE_NOT_IMPLEMENTED\r\n   Description: \'IAnimal.run\' not found on \'animal_0\'\r\n\r\n    at throwErrorMessage (D:\\_Dev\\NodeJS\\github\\mixin-interface-api\\src\\mixin_interface_api.js:31:11)\r\n    at Object.$raiseNotImplementedError (D:\\_Dev\\NodeJS\\github\\mixin-interface-api\\src\\mixin_interface_api.js:45:9)\r\n    at Animal.run (D:\\_Dev\\NodeJS\\github\\mixin-interface-api\\src\\test_classes\\i_animal.js:16:9)\r\n    at Object.<anonymous> (D:\\_Dev\\NodeJS\\github\\mixin-interface-api\\test.js:34:13)\r\n    ...\r\n...\r\n```\r\n\r\n***\r\n## Delayed Object Initialization\r\n```javascript\r\nMxI.$Object().init(...args_init)\r\nMxI.$Object().isInitialized()\r\n```\r\nThese services provide the _Delayed Initialization_ feature. \r\n>Once `init()` service is called, if `args_init` is provided it is accessible to all instances of implementation class(es) via `this._$args_init`. \r\n\r\n>An object may be initialized only once: `this._$args_init` cannot then be set or changed.\r\n\r\n>Short explanation on _Delayed Initialization_: a typical example in _GUI programming_ is when you need a widget (e.g. _PushButton_) but its container (e.g. _CommandBar_) is not yet created or known at instanciation time, so you may use later  `init()` service so that the PushButton can set its container (e.g. by calling setContainer() in the _PushButton_\'s implementation of init() service).\r\n\r\n***\r\n## \'Singleton\' feature\r\n```javascript\r\nMxI.$ISingleton\r\nMxI.$Singleton\r\nMxI.$isSingleton(object) \r\nMxI.$setAsSingleton(implementation)\r\n```\r\n\r\nPlease find below a code sample from [`./test_.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/test.js) which uses `MxI.$isSingleton()`:\r\n```javascript\r\nMxI.$Log.write("isSingleton(%s):  %s", MxI.$Null, MxI.$isSingleton(MxI.$Null));\r\n```\r\n\r\nPlease find below a code sample from [`./src/mixin_interface_api.js`](https://github.com/Echopraxium/mixin-interface-api/blob/master/src/mixin_interface_api.js) which uses `MxI.$setAsSingleton()`:\r\n```javascript\r\nclass $NullObject extends $Implementation($Singleton).$with($ISingleton, $INullObject) { \r\n    constructor(...args) {\r\n\t    super();\r\n        this._$name = MXI_NULL;\r\n    } // \'$NullObject\' constructor\r\n} // \'$NullObject\' implementation class\r\n$setClass($NullObject).$asImplementationOf($INullObject, $ISingleton);\r\n$setAsSingleton($NullObject);\r\n```\r\n\r\n***\r\n## \'Null Object\' feature\r\n```javascript\r\nMxI.$INullObject\r\nMxI.$NullObject\r\nMxI.$Null\r\nMxI.$isNull(object)\r\n```\r\n\r\nExample: a default implementation of `MxI.$INullObject` _interface_\r\n```javascript\r\nclass $NullObject extends $Implementation($Singleton).$with($ISingleton, $INullObject) { \r\n    constructor(...args) {\r\n\t    super();\r\n        this._$name = MXI_NULL;\r\n    } // \'$NullObject\' constructor\r\n} // \'$NullObject\' implementation class\r\n$setClass($NullObject).$asImplementationOf($INullObject, $ISingleton);\r\n$setAsSingleton($NullObject);\r\n```\r\n\r\nPlease find below a code sample which both logs `MxI.$Null` singleton and calls `MxI.$isNull()`\r\n```javascript\r\nMxI.$Log.write("MxI.$isNull(%s):   %s", MxI.$Null, MxI.$isNull(MxI.$Null));\r\n```\r\n\r\n> `MxI.$isNull()` Returns `true` in 2 cases. The first is when the input value is an object which is both a _Null Object_ an a _Singleton_ (typically the \'default Null Object\' which is `MxI.$Null`). The second case is when the input value is `undefined`\r\n\r\n\r\n## Installation and Usage\r\n```bash\r\nnpm install mixin-interface-api -S\r\n```\r\n\r\n## How to run the Unit Test\r\n#### Step 1: Install Prerequisite Tools\r\nInstall [_NodeJS_](https://nodejs.org/en/) and [_Git_](https://git-scm.com/)\r\n\r\n#### Step 2: Clone the \'mixin-interface-api\' repository locally\r\nOpen a command shell then enter the following commands:\r\n```bash\r\ngit clone git://github.com/Echopraxium/mixin-interface-api\r\ncd mixin-interface-api\r\nnpm update\r\n```\r\n\r\n#### Step 3: Run the Unit Test\r\nNow enter the following command:\r\n```bash\r\nnode test.js\r\n```\r\n\r\nYou should get this kind of output (please find [here](https://github.com/Echopraxium/mixin-interface-api/blob/master/log.txt) the full output):\r\n```bash\r\n=============================================================\r\n======== Unit Test for \'mixin-interface-api\' package ========\r\n=============================================================\r\n1.Instance of \'Animal\' created: animal_0\r\n\'animal_0\' is a \'MxI.$Object\' ?    true\r\n\'animal_0\' is a \'ILifeForm\' ?      true\r\n\'animal_0\' is a \'IAnimal\' ?        true\r\n\'animal_0\' is a \'Animal\' ?         true\r\n\'animal_0\' is a \'IMammal\' ?        false\r\n--> Animal.run\r\n--> Animal.live\r\n----------\r\n2. Instance of \'Cat\' created: cat_0\r\n\'cat_0\' is a \'MxI.$Object\' ? true\r\n\'cat_0\' is a \'Animal\' ?      true\r\n\'cat_0\' is a \'Cat\' ?         true\r\n\'cat_0\' is a \'ILifeForm\' ?   true\r\n\'cat_0\' is a \'IAnimal\' ?     true\r\n\'cat_0\' is a \'IMammal\' ?     true\r\n--> Animal.run\r\n--> Cat.suckle\r\n--> Animal.live\r\n...\r\n```\r\n\r\n>Please notice in the previous output that an _implementation class_ may _inherit_ functions (i.e implementation of services from _interface classes_) from its parent class (e.g. `FlyingFish` inherits `IAnimal.run()` and `IAnimal.live()` from `Animal`) but it is also possible to _override_ these default implementations them as well.\r\n\r\n## References\r\n* _API Design: Avoid Logging in your APIs_  \r\n  http://tutorials.jenkov.com/api-design/avoid-logging.html\r\n* _A fresh look at JavaScript Mixins_  \r\n  https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/\r\n* _Functional Mixins in ECMAScript 2015_   \r\n  http://raganwald.com/2015/06/17/functional-mixins.html\r\n* _JavaScript Mixins: Beyond Simple Object Extension_\r\n  https://lostechies.com/derickbailey/2012/10/07/javascript-mixins-beyond-simple-object-extension/\r\n* _"Real" Mixins with JavaScript Classes_\r\n  http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\r\n* _Classes versus Prototypes in Object-Oriented Languages_\r\n  ftp://ftp.cs.washington.edu/pub/constraints/papers/fjcc-86.pdf\r\n* _The Theory of Classification - Part 15: Mixins and the Superclass Interface_  \r\n  http://www.jot.fm/issues/issue_2004_11/column1/\r\n* _CSE 505 Lecture Notes Archive - Prototype-based Programming_\r\n  https://en.wikipedia.org/wiki/Prototype-based_programming\r\n* _19. Classes, Metaclasses, and Prototype-Based Languages_\r\n  https://courses.cs.washington.edu/courses/cse505/00au/lectures/19-metaclasses.txt\r\n* _Safe Metaclass Composition Using Mixin-Based Inheritance - ESUG_\r\n  http://www.esug.org/data/ESUG2003/mixinsforsafemetaclasscomposition.nourybouraqadi.bled25aug2003.pdf\r\n* _CSE 341: Smalltalk classes and metaclasses_\r\n  http://courses.cs.washington.edu/courses/cse341/04wi/lectures/17-smalltalk-classes.html\r\n* _Topiarist: A JavaScript OO library featuring mixins, interfaces & multiple inheritance_  \r\n  http://bladerunnerjs.org/blog/topiarist/',
21 silly publish   readmeFilename: 'README.md',
21 silly publish   gitHead: 'bcd18dfc33a431d07cd280cf140e60b579993c79',
21 silly publish   _id: 'mixin-interface-api@0.1.17',
21 silly publish   _shasum: 'e2e39bb5a500a99e4b6f573eca43ad0f5c45001a',
21 silly publish   _from: '.' }
22 verbose getPublishConfig undefined
23 silly mapToRegistry name mixin-interface-api
24 silly mapToRegistry using default registry
25 silly mapToRegistry registry https://registry.npmjs.org/
26 silly mapToRegistry data Result {
26 silly mapToRegistry   raw: 'mixin-interface-api',
26 silly mapToRegistry   scope: null,
26 silly mapToRegistry   escapedName: 'mixin-interface-api',
26 silly mapToRegistry   name: 'mixin-interface-api',
26 silly mapToRegistry   rawSpec: '',
26 silly mapToRegistry   spec: 'latest',
26 silly mapToRegistry   type: 'tag' }
27 silly mapToRegistry uri https://registry.npmjs.org/mixin-interface-api
28 verbose publish registryBase https://registry.npmjs.org/
29 silly publish uploading C:\Users\maruti\AppData\Roaming\npm-cache\mixin-interface-api\0.1.17\package.tgz
30 verbose request uri https://registry.npmjs.org/mixin-interface-api
31 verbose request sending authorization for write operation
32 info attempt registry request try #1 at 22:44:45
33 verbose request using bearer token for auth
34 verbose request id 29ee8ca3a31d9d45
35 http request PUT https://registry.npmjs.org/mixin-interface-api
36 http 403 https://registry.npmjs.org/mixin-interface-api
37 verbose headers { 'content-type': 'application/json',
37 verbose headers   'cache-control': 'max-age=300',
37 verbose headers   'content-length': '92',
37 verbose headers   'accept-ranges': 'bytes',
37 verbose headers   date: 'Fri, 02 Feb 2018 21:44:44 GMT',
37 verbose headers   via: '1.1 varnish',
37 verbose headers   connection: 'keep-alive',
37 verbose headers   'x-served-by': 'cache-ams4140-AMS',
37 verbose headers   'x-cache': 'MISS',
37 verbose headers   'x-cache-hits': '0',
37 verbose headers   'x-timer': 'S1517607884.513812,VS0,VE1365',
37 verbose headers   vary: 'Accept-Encoding, Accept' }
38 verbose request invalidating C:\Users\maruti\AppData\Roaming\npm-cache\registry.npmjs.org\mixin-interface-api on PUT
39 error publish Failed PUT 403
40 verbose stack Error: You cannot publish over the previously published version 0.1.17. : mixin-interface-api
40 verbose stack     at makeError (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:302:12)
40 verbose stack     at CachingRegistryClient.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:290:14)
40 verbose stack     at Request._callback (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:210:14)
40 verbose stack     at Request.self.callback (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:187:22)
40 verbose stack     at emitTwo (events.js:106:13)
40 verbose stack     at Request.emit (events.js:191:7)
40 verbose stack     at Request.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:1048:10)
40 verbose stack     at emitOne (events.js:96:13)
40 verbose stack     at Request.emit (events.js:188:7)
40 verbose stack     at IncomingMessage.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:969:12)
41 verbose statusCode 403
42 verbose pkgid mixin-interface-api
43 verbose cwd D:\_Dev\NodeJS\github\mixin-interface-api
44 error Windows_NT 10.0.16299
45 error argv "C:\\Program Files\\nodejs\\node.exe" "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js" "publish"
46 error node v6.10.3
47 error npm  v3.10.10
48 error code E403
49 error You cannot publish over the previously published version 0.1.17. : mixin-interface-api
50 error If you need help, you may report this error at:
50 error     <https://github.com/npm/npm/issues>
51 verbose exit [ 1, true ]
